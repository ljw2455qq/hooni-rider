<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>RTIRL 거리 오버레이</title>
    <style>
        /* 기본 스타일(필요에 따라 조정) */
        body { margin:0; font-family:"Noto Sans KR", sans-serif; background:#111;color:#eee;}
        #distanceContainer{position:absolute;top:20px;left:20px;background:rgba(0,0,0,.5);padding:10px 15px;border-radius:8px;}
        #distanceValue{font-size:2rem;font-weight:bold;}
        .status{margin-top:6px;font-size:.9rem;color:#888;}
        .status.connected{color:#0f0;}
        .status.disconnected{color:#f00;}
    </style>
</head>
<body>
<div id="distanceContainer">
    <div id="distanceValue">--<span class="distance-unit">km</span></div>
    <div id="status" class="status">연결 중...</div>
</div>

<script>
// -------------------------------------------------------
// 1️⃣ API 키를 직접 코드에 넣습니다
const apiKey = 'pk.eyJ1Ijoia2V2bW8zMTQiLCJhIjoiY2w0MW1qaTh3MG80dzNjcXRndmJ0a2JieiJ9.Y_xABmAqvD-qZeed8MabxQ'; // ← 여기에 키가 들어갑니다

// 2️⃣ URL 파라미터는 선택 사항(테마, 리프레시 등)
//    key 파라미터를 넣지 않아도 apiKey 변수가 사용됩니다
const urlParams = new URLSearchParams(window.location.search);
const theme   = urlParams.get('theme') || 'default';
const refreshInterval = parseInt(urlParams.get('refresh')) || 5000;

// 3️⃣ 테마 적용(필요 시)
if (theme !== 'default') {
    document.getElementById('distanceContainer').classList.add(`theme-${theme}`);
}

// 상태 요소
const distanceValueEl = document.getElementById('distanceValue');
const statusEl        = document.getElementById('status');

// -------------------------------------------------------
// 4️⃣ 거리 데이터 가져오기 (HTTP 폴링)
async function fetchDistance() {
    try {
        statusEl.textContent = '업데이트 중...';
        statusEl.className   = 'status connecting';

        const response = await fetch(`https://overlays.rtirl.com/api/distance?key=${apiKey}`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const data = await response.json();
        const distanceKm = (data.distance / 1000).toFixed(2);
        distanceValueEl.innerHTML = `${distanceKm}<span class="distance-unit">km</span>`;
        statusEl.textContent = '연결됨';
        statusEl.className   = 'status connected';
    } catch (err) {
        console.error('거리 데이터 가져오기 실패:', err);
        distanceValueEl.innerHTML = `--<span class="distance-unit">km</span>`;
        statusEl.textContent = '연결 실패';
        statusEl.className   = 'status disconnected';
    }
}

// 5️⃣ WebSocket 연결 시도
function connectWebSocket() {
    try {
        const ws = new WebSocket(`wss://overlays.rtirl.com/ws?key=${apiKey}`);

        ws.onopen = () => {
            statusEl.textContent = '실시간 연결';
            statusEl.className   = 'status connected';
        };

        ws.onmessage = e => {
            const data = JSON.parse(e.data);
            if (data.type === 'distance') {
                const distanceKm = (data.value / 1000).toFixed(2);
                distanceValueEl.innerHTML = `${distanceKm}<span class="distance-unit">km</span>`;
            }
        };

        ws.onclose = () => {
            statusEl.textContent = '연결 끊김';
            statusEl.className   = 'status disconnected';
            setTimeout(connectWebSocket, 5000); // 재접속
        };

        ws.onerror = () => {
            console.warn('WebSocket 실패 → HTTP 폴링으로 전환');
            startPolling();
        };
    } catch (err) {
        startPolling(); // 예외 시 바로 폴링 시작
    }
}

// 6️⃣ HTTP 폴링 루프
function startPolling() {
    fetchDistance();
    setInterval(fetchDistance, refreshInterval);
}

// -------------------------------------------------------
// 초기화
function init() {
    if (!apiKey || apiKey === 'YOUR_PULL_KEY') {
        statusEl.textContent = 'API 키 필요';
        statusEl.className   = 'status disconnected';
        distanceValueEl.innerHTML = `--<span class="distance-unit">km</span>`;
        return;
    }

    // direct 옵션이 없으니 바로 WebSocket 시도
    connectWebSocket();
}

// 페이지 로드 시 실행
window.addEventListener('load', init);

// 페이지가 다시 보일 때 재연결 (옵션)
document.addEventListener('visibilitychange', () => {
    if (!document.hidden) init();
});
</script>
</body>
</html>
