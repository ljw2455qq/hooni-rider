<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>거리 표시 오버레이</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
            overflow: hidden;
        }

        .distance-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(50, 50, 50, 0.8));
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 25px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            text-align: center;
        }

        .distance-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
        }

        .distance-value {
            font-size: 32px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            font-family: 'Courier New', monospace;
            margin: 0;
            line-height: 1;
        }

        .distance-unit {
            font-size: 16px;
            color: rgba(255, 255, 255, 0.9);
            margin-left: 5px;
            font-weight: normal;
        }

        .status {
            font-size: 10px;
            margin-top: 8px;
            padding: 4px 8px;
            border-radius: 8px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status.connected {
            background: rgba(76, 175, 80, 0.8);
            color: white;
        }

        .status.connecting {
            background: rgba(255, 152, 0, 0.8);
            color: white;
            animation: pulse 2s infinite;
        }

        .status.disconnected {
            background: rgba(244, 67, 54, 0.8);
            color: white;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .icon {
            font-size: 14px;
            margin-right: 5px;
        }

        /* 다양한 테마 옵션 */
        .theme-minimal {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .theme-gaming {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.8), rgba(30, 144, 255, 0.8));
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .theme-neon {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }

        .theme-neon .distance-value {
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
    </style>
</head>
<body>
    <div class="distance-container" id="distanceContainer">
        <div class="distance-label">
            <span class="icon">🏃‍♂️</span>총 거리
        </div>
        <div class="distance-value" id="distanceValue">
            0.00<span class="distance-unit">km</span>
        </div>
        <div class="status connecting" id="status">
            연결 중...
        </div>
    </div>

    <script>
        // URL 파라미터에서 키와 설정 가져오기
        const urlParams = new URLSearchParams(window.location.search);
        const apiKey = urlParams.get('key') || 'zeoeyze9htbyx455';
        const theme = urlParams.get('theme') || 'default';
        const refreshInterval = parseInt(urlParams.get('refresh')) || 5000; // 5초마다 업데이트

        // 테마 적용
        if (theme !== 'default') {
            document.getElementById('distanceContainer').classList.add(`theme-${theme}`);
        }

        // 상태 요소들
        const distanceValueEl = document.getElementById('distanceValue');
        const statusEl = document.getElementById('status');

        // RTIRL API에서 거리 데이터 가져오기
        async function fetchDistance() {
            try {
                statusEl.textContent = '업데이트 중...';
                statusEl.className = 'status connecting';

                // RTIRL API 호출 (실제 API 엔드포인트는 문서 확인 필요)
                const response = await fetch(`https://overlays.rtirl.com/api/distance?key=${apiKey}`);
                
                if (response.ok) {
                    const data = await response.json();
                    const distanceKm = (data.distance / 1000).toFixed(2); // 미터를 킬로미터로 변환
                    
                    distanceValueEl.innerHTML = `${distanceKm}<span class="distance-unit">km</span>`;
                    statusEl.textContent = '연결됨';
                    statusEl.className = 'status connected';
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('거리 데이터 가져오기 실패:', error);
                distanceValueEl.innerHTML = `--<span class="distance-unit">km</span>`;
                statusEl.textContent = '연결 실패';
                statusEl.className = 'status disconnected';
            }
        }

        // iframe으로 RTIRL 거리 오버레이 직접 로드 (대안 방법)
        function loadRTIRLOverlay() {
            if (apiKey !== 'zeoeyze9htbyx455') {
                const iframe = document.createElement('iframe');
                iframe.src = `https://overlays.rtirl.com/distance/km.html?key=${apiKey}`;
                iframe.style.width = '100%';
                iframe.style.height = '100%';
                iframe.style.border = 'none';
                iframe.style.background = 'transparent';
                
                // 기존 컨테이너 숨기고 iframe 표시
                document.body.innerHTML = '';
                document.body.appendChild(iframe);
                return;
            }
        }

        // WebSocket 연결 시도 (실시간 업데이트)
        function connectWebSocket() {
            try {
                const ws = new WebSocket(`wss://overlays.rtirl.com/ws?key=${apiKey}`);
                
                ws.onopen = function() {
                    statusEl.textContent = '실시간 연결';
                    statusEl.className = 'status connected';
                };

                ws.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    if (data.type === 'distance') {
                        const distanceKm = (data.value / 1000).toFixed(2);
                        distanceValueEl.innerHTML = `${distanceKm}<span class="distance-unit">km</span>`;
                    }
                };

                ws.onclose = function() {
                    statusEl.textContent = '연결 끊김';
                    statusEl.className = 'status disconnected';
                    // 5초 후 재연결 시도
                    setTimeout(connectWebSocket, 5000);
                };

                ws.onerror = function() {
                    // WebSocket 실패 시 HTTP 폴링으로 대체
                    console.log('WebSocket 실패, HTTP 폴링으로 전환');
                    startPolling();
                };
            } catch (error) {
                startPolling();
            }
        }

        // HTTP 폴링 시작
        function startPolling() {
            fetchDistance();
            setInterval(fetchDistance, refreshInterval);
        }

        // 초기화
        function init() {
            if (apiKey === 'YOUR_PULL_KEY') {
                statusEl.textContent = 'API 키 필요';
                statusEl.className = 'status disconnected';
                distanceValueEl.innerHTML = `--<span class="distance-unit">km</span>`;
                return;
            }

            // RTIRL 오버레이 직접 로드 옵션
            const useDirectOverlay = urlParams.get('direct') === 'true';
            if (useDirectOverlay) {
                loadRTIRLOverlay();
                return;
            }

            // WebSocket 연결 시도, 실패 시 HTTP 폴링
            connectWebSocket();
        }

        // 페이지 로드 시 초기화
        window.addEventListener('load', init);

        // 페이지 visibility 변경 시 연결 관리
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // 페이지가 숨겨지면 연결 일시 정지
            } else {
                // 페이지가 다시 보이면 연결 재개
                init();
            }
        });
    </script>
</body>
</html>
